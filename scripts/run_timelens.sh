#!/usr/bin/env bash
# Script to do inference and evaluation of rpg_event_representation_learning

root_path=$POLED_PATH

# Parse YAML function
source "$root_path"/scripts/parse_yaml.sh

# Parse the master YAML file
eval $(parse_yaml "$root_path"/config/master.yaml)
# Parse datasets paths YAML file (datasets)
datasets_yaml="$common_root"/"$common_cfg_root"/"$common_cfg_datasets"/"$datasets_cfg_file"
eval $(parse_yaml "$datasets_yaml")
# Parse the OLED YAML file (oled)
oled_yaml="$common_root"/"$common_cfg_root"/"$common_cfg_sampling"/"$oled_cfg_file"
eval $(parse_yaml "$oled_yaml")
# Parse timelens YAML file (method)
method_yaml="$common_root"/"$common_cfg_root"/"$common_cfg_methods"/"$timelens_cfg_file"
eval $(parse_yaml "$method_yaml")

# From OLED
for exp_cfg in "${oled_exp_cfgs[@]}"; do
  # Get experiment ID from the config file
  exp_yaml="$common_root"/"$common_cfg_root"/"$common_cfg_sampling"/"$exp_cfg"
  eval $(parse_yaml "$exp_yaml")
  exp_name="$sampler_params_exp_name"
  # From METHOD
  for dataset_name in "${method_datasets_name[@]}"; do
    var_dataset_root="$dataset_name"_root  # Get the variable Name (e.g. N-Caltech101_root, hsergb_root, ...)
    var_dataset_seqs="$dataset_name"_seqs
    var_dataset_eval="$dataset_name"_eval
    dataset_root="${!var_dataset_root}"  # Get the value of the variable generated by datasets_paths.yaml
    dataset_seqs="${!var_dataset_seqs}"
    dataset_eval="${!var_dataset_eval}"
    # TODO: Specifiy split (testing...)
    dataset_sys_path="$datasets_common_root"/"$dataset_root"  # Path to the dataset in the system
    dataset_docker_path="$method_docker_datasets"/"$dataset_root"  # Path to the dataset within the docker container
    dataset_sys_seqs_path="$dataset_sys_path"/"$dataset_seqs"
    dataset_docker_seqs_path="$dataset_docker_path"/"$dataset_seqs"
    dataset_sys_eval_path="$dataset_sys_path"/"$dataset_eval"
    dataset_docker_eval_path="$dataset_docker_path"/"$dataset_eval"
    # Read the sequences to "seqs_tlens"
    readarray -d '' seqs_tlens < <(find "$dataset_sys_seqs_path" -mindepth 1 -maxdepth 1 -type d -print0)
    # From OLED
    for sampler in "${oled_samplers[@]}"; do
      # From OLED
      for run in "${oled_runs[@]}"; do
        # From OLED
        for prob_init in "${oled_prob_inits[@]}"; do
          # Evaluate the downsampled events per method
          if [[ "$prob_init" == "10" ]]; then
            prob_init_dec=1
          else
            prob_init_dec="0."$prob_init
          fi
          run_descriptor="$sampler"_"$prob_init_dec"-"$run"
          
          echo "Running experiments for" "$run_descriptor", "experiment:" "$exp_name"

          # From METHOD (Timelens)
          for idx in "${!method_skips[@]}"; do
            skip=${method_skips[idx]}
            insert=${method_inserts[idx]}

            # LOGS (per skip)
            logs_sys_path="$common_root"/"$common_logs_path"/"$dataset_name"/"$method_name"/"$exp_name"/skip_"$skip"/"$run_descriptor"
            logs_docker_path="$method_docker_app"/"$common_logs_path"/"$dataset_name"/"$method_name"/"$exp_name"/skip_"$skip"/"$run_descriptor"
            mkdir -p "$logs_sys_path"
            chmod 777 "$logs_sys_path"
            logs_docker_res="$logs_docker_path"/"$common_logs_res_file"
            logs_res="$logs_sys_path"/"$common_logs_res_file"
            logs_size="$logs_sys_path"/"$common_logs_size_file"
            logs_time="$logs_sys_path"/"$common_logs_time_file"        

            echo "Running Timelens, Saving logs to: $logs_res..."
            start_time=$(date +%s)
            
            # Debug
            for seq in "${seqs_tlens[@]}"; do
              seq_name=$(basename "$seq")
              if [[ ${#method_seqs_list[@]} -gt 0 ]]; then
                if [[ ! " ${method_seqs_list[*]} " =~ " ${seq_name} " ]]; then
                  continue
                fi
              fi

              # hs-ergb/sampling/hsergb_conversion/seqs/baloon_popping
              data_sys_path="$dataset_sys_seqs_path"/"$seq_name"
              data_docker_path="$dataset_docker_seqs_path"/"$seq_name"

              # TODO: Specify this "sampling" or "original" in YAML files
              events_sys_path="$data_sys_path"/events/"$exp_name"/events_"$run_descriptor"
              events_docker_path="$data_docker_path"/events/"$exp_name"/events_"$run_descriptor"
              images_docker_path="$data_docker_path"/"$method_images"
              output_docker_path="$data_docker_path"/"$method_output"/"$exp_name"/skip_"$skip"/output_"$run_descriptor"
              
              # RUN (per sequence)
              docker exec -it "$method_docker_id" \
                env PYTHONPATH="$method_docker_app":"$PYTHONPATH" \
                python "$method_run" "$method_docker_app"/"$method_model_path"/"$method_checkpoint" \
                "$events_docker_path" "$images_docker_path" "$output_docker_path" \
                "$skip" "$insert"
              
            done
            
            end_time=$(date +%s)
            echo time: "$((end_time-start_time))" > "$logs_time"
            echo size: "$(du -shLc "$dataset_sys_seqs_path"/*/events/"$exp_name"/events_"$run_descriptor")" > "$logs_size"
            
            # EVALUATE

            # Original: .../seqs/baloon_popping/outputs/cvpr25/skip_10/output_poisson_0.1-1
            # Replicate the evaluation script folder structure
            # results_folder           <------ .../eval/cvpr25/skip_10
            # ├── sequence_0
            # │   ├── GT               <------ this is where ground truth images are stored
            # │   │   ├── 000000.png
            # │   │   ├── 000001.png
            # │   │   └── ...
            # │   ├── method_0          <------ method_0 = poisson_0.5-1
            # │   │   ├── 000000.png
            # │   │   ├── 000001.png
            # │   │   └── ...
            # │   ├── method_1
            # │   │   ├── 000000.png
            # │   │   ├── 000001.png
            # │   │   └── ...
            # │   └── ...
            # ├── sequence_1
            # │   ├── GT
            # │   │   ├── 000000.png
            # │   │   ├── 000001.png
            # │   │   └── ...
            # │   └── ...
            # └── ...        

            # Generate eval folder and link to GT images and outputs
            eval_sys_path="$dataset_sys_eval_path"/"$exp_name"/skip_"$skip"
            eval_docker_path="$dataset_docker_eval_path"/"$exp_name"/skip_"$skip"

            # For each sequence, copy the ground truth symlinks to the eval path
            for seq in "${seqs_tlens[@]}"; do
                seq_name=$(basename "$seq")
                images_sys_seq_path="$dataset_sys_seqs_path"/"$seq_name"/"$method_images"
                eval_sys_seq_path="$eval_sys_path"/"$seq_name"
                output_sys_seq_path="$dataset_sys_seqs_path"/"$seq_name"/"$method_output"/"$exp_name"/skip_"$skip"/output_"$run_descriptor"

                echo "$output_sys_seq_path"
                mkdir -p "$eval_sys_seq_path"/"$method_eval_gt"
                mkdir -p "$eval_sys_seq_path"/"$run_descriptor"

                # Create relative symlinks for GT images
                for img in "$images_sys_seq_path"/*.png; do
                    img_name=$(basename "$img")
                    rel_path=$(realpath --relative-to="$eval_sys_seq_path"/"$method_eval_gt" "$img")
                    ln -sf "$rel_path" "$eval_sys_seq_path"/"$method_eval_gt"/"$img_name"
                done

                # Create relative symlinks for output images
                for output in "$output_sys_seq_path"/*.png; do
                    output_name=$(basename "$output")
                    rel_path=$(realpath --relative-to="$eval_sys_seq_path"/"$run_descriptor" "$output")
                    ln -sf "$rel_path" "$eval_sys_seq_path"/"$run_descriptor"/"$output_name"
                done
            done

            # Make logs folder inside the docker container
            docker exec -it "$method_docker_id" mkdir -p "$logs_docker_path"

            # Evaluate            
            if [[ ${#method_seqs_list[@]} -gt 0 ]]; then
              # Debug (Evaluate for specific sequences)
              docker exec -it "$method_docker_id" \
                env PYTHONPATH="$method_docker_app":"$PYTHONPATH" \
                python "$method_eval" "$eval_docker_path" \
                --seqs "${method_seqs_list[@]}" \
                --methods "$run_descriptor" \
                --num_skips "$skip" -n "$method_eval_workers" -o "$logs_docker_res"_debug
              
              # Copy local logs to system logs
              docker cp "$method_docker_id":${logs_docker_res}_debug ${logs_res}_debug

            else
              docker exec -it "$method_docker_id" \
                env PYTHONPATH="$method_docker_app":"$PYTHONPATH" \
                python "$method_eval" "$eval_docker_path" \
                --methods "$run_descriptor" \
                --num_skips "$skip" -n "$method_eval_workers" -o "$logs_docker_res"

              # Copy local logs to system logs
              docker cp "$method_docker_id":${logs_docker_res} ${logs_res}
            fi 
          done
        done
      done
    done
  done
done
